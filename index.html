<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>æ¬¢è¿æ•å®~</title>
		<link rel="preconnect" href="https://er-sycdn.kuwo.cn" crossorigin>
		<link rel="preload" as="audio" href="https://er-sycdn.kuwo.cn/e9c282d09505555326ebc12270e3f6be/690413c2/resource/30106/trackmedia/C200004A5exG06C63T.m4a?from=vip" crossorigin>
		<style>
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
				background-image: linear-gradient(0deg, #eee 1px, transparent 0),
					linear-gradient(90deg, #eee 1px, transparent 0);
				background-size: 30px 30px;
				color: #333;
				min-height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile {
				overflow-y: auto;
			}

			#board {
				position: relative;
				width: 100vw;
				height: 100dvh;
				overflow: hidden;
			}

			body.is-mobile #board {
				height: auto;
				min-height: 100dvh;
			}

			.card {
				position: absolute;
				width: 220px;
				border-radius: 12px;
				box-shadow: 0 16px 35px rgba(0, 0, 0, 0.2);
				background: #fff;
				border: 1px solid rgba(0, 0, 0, 0.08);
				overflow: hidden;
				opacity: 0;
				transform-origin: center;
				transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
					top 0.35s ease, width 0.35s ease, height 0.35s ease,
					border-radius 0.35s ease;
			}

			.card.dragging {
				transition: none;
				box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
			}

			.card.maximized {
				box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
			}

			.card-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 10px 12px;
				background: rgba(255, 255, 255, 0.7);
				cursor: grab;
				user-select: none;
				touch-action: pan-y;
			}

			.card-header.dragging {
				cursor: grabbing;
			}

			.window-controls {
				display: flex;
				align-items: center;
				gap: 6px;
			}

			.window-controls .control {
				position: relative;
				width: 12px;
				height: 12px;
				border-radius: 50%;
				border: 1px solid rgba(0, 0, 0, 0.08);
				background: #ccc;
				cursor: pointer;
				outline: none;
				padding: 0;
				display: inline-flex;
				align-items: center;
				justify-content: center;
			}

			.window-controls .control.close {
				background: #ff5f57;
				border-color: #e0443e;
			}

			.window-controls .control.minimize {
				background: #febb2e;
				border-color: #dea123;
			}

			.window-controls .control.maximize {
				background: #28c840;
				border-color: #1aab2c;
			}

			.window-controls .control::after {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				opacity: 0;
				transition: opacity 0.2s ease;
			}

			.card-header:hover .window-controls .control::after {
				opacity: 0.8;
			}

			.window-controls .control.close::after {
				content: 'Ã—';
				width: auto;
				height: auto;
				background: none;
				font-size: 10px;
				line-height: 1;
				font-weight: 700;
				color: rgba(0, 0, 0, 0.7);
			}

			.window-controls .control.minimize::after {
				width: 6px;
				height: 2px;
				background: rgba(0, 0, 0, 0.6);
			}

			.window-controls .control.maximize::after {
				width: 6px;
				height: 6px;
				background: linear-gradient(
					45deg,
					rgba(0, 0, 0, 0.6) 0%,
					rgba(0, 0, 0, 0.6) 45%,
					transparent 45%,
					transparent 55%,
					rgba(0, 0, 0, 0.6) 55%,
					rgba(0, 0, 0, 0.6) 100%
				);
			}

			.card-title {
				font-size: 13px;
				font-weight: 600;
				color: rgba(0, 0, 0, 0.55);
				padding-left: 10px;
				flex: 1;
			}

			.card-body {
				padding: 16px;
				font-size: 16px;
				line-height: 1.4;
				font-weight: 600;
				color: rgba(0, 0, 0, 0.72);
			}

			@media (max-width: 768px) {
				.card {
					width: 180px;
					border-radius: 10px;
				}

				.card-body {
					padding: 14px;
					font-size: 14px;
				}

				.card-title {
					font-size: 12px;
				}
			}
		</style>
		<style>
			/* èƒŒæ™¯çƒŸèŠ±ç”»å¸ƒï¼ˆåœ¨å¼¹çª—èƒŒæ™¯åé¢ï¼‰ */
			#fireworks-canvas {
				position: fixed;
				inset: 0;
				pointer-events: none;
				z-index: 1000000; /* æ¯”å¼¹çª—(1000001)ä½ï¼Œä¿è¯åœ¨å…¶åé¢ */
			}
		</style>
	</head>
	<body>
		<canvas id="fireworks-canvas"></canvas>
		<div id="board"></div>

		<!-- èƒŒæ™¯éŸ³ä¹ï¼šä½¿ç”¨ä½ æä¾›çš„é“¾æ¥ï¼Œç‚¹å‡»â€œç¡®å®šâ€åæ’­æ”¾ -->
		<audio id="bgm" src="https://er-sycdn.kuwo.cn/e9c282d09505555326ebc12270e3f6be/690413c2/resource/30106/trackmedia/C200004A5exG06C63T.m4a?from=vip" preload="auto" loop playsinline></audio>
		<style>
			.modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center; z-index: 1000001; }
			.modal-card { width: 300px; background:#fff; border-radius:12px; box-shadow:0 16px 35px rgba(0,0,0,.2); overflow:hidden; }
			.modal-title { padding:12px 16px; font-size:16px; font-weight:600; border-bottom:1px solid rgba(0,0,0,0.08); }
			.modal-body { padding:16px; font-size:14px; color: rgba(0,0,0,.75); }
			.modal-confirm { margin: 0 16px 16px; padding: 8px 12px; width: calc(100% - 32px); background:#2b6cb0; color:#fff; border:none; border-radius:8px; cursor:pointer; }
			.modal-confirm:hover { background:#2c5282; }
		</style>
		<div id="musicModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="musicModalTitle">
			<div class="modal-card">
				<div id="musicModalTitle" class="modal-title">ä½œè€…:å°é¾™å­</div>
				<div class="modal-body">å•å‡»'ç¡®å®š'è¿›å…¥å…¨å±/'ESCé”®'é€€å‡ºå…¨å±</div>
				<button id="confirmPlay" class="modal-confirm" type="button">ç¡®å®š</button>
			</div>
		</div>
		<script>
			const bgm = document.getElementById('bgm');
			const modal = document.getElementById('musicModal');
			const confirmBtn = document.getElementById('confirmPlay');
			// é¡µé¢åŠ è½½æ—¶å±•ç¤ºå¼¹çª—
			modal.style.display = 'flex';
			bgm.load();
			confirmBtn.addEventListener('click', () => {
				// è¿›å…¥å…¨å±ï¼ˆéœ€ç”¨æˆ·ç‚¹å‡»æ‰‹åŠ¿è§¦å‘ï¼‰
				const root = document.documentElement;
				if (!document.fullscreenElement && root.requestFullscreen) {
					root.requestFullscreen({ navigationUI: 'hide' }).catch(() => {});
				}

				// æ’­æ”¾èƒŒæ™¯éŸ³ä¹
				bgm.play().then(() => {
					modal.remove();
				}).catch(() => {
					// æ’­æ”¾å¤±è´¥åˆ™ä¿ç•™å¼¹çª—ä»¥ä¾¿ç”¨æˆ·å†æ¬¡ç‚¹å‡»
				});
			});
		</script>

		<script>
			(function () {
				const canvas = document.getElementById('fireworks-canvas');
				if (!canvas) return;
				const ctx = canvas.getContext('2d');

				// å‚æ•°ï¼ˆå¯æ ¹æ®éœ€è¦å¾®è°ƒï¼‰
				const spawnInterval = 700;   // è‡ªåŠ¨å‘å°„é—´éš”ï¼ˆæ¯«ç§’ï¼‰
				const maxRockets = 5;        // åŒå±æœ€å¤šä¸Šå‡ç«ç®­
				const maxParticles = 600;    // ç²’å­æ€»é‡ä¸Šé™
				const gravity = 0.035;       // é‡åŠ›
				const friction = 0.985;      // æ‘©æ“¦ï¼ˆè¶Šå°æ‰©æ•£è¶Šå¤§ï¼‰
				const colors = ['#ff2d2d', '#ffd700', '#32cd32', '#00bfff', '#ff69b4', '#ffa500'];

				let width = 0, height = 0, dpr = 1;
				let rockets = [];
				let particles = [];
				let lastSpawn = 0;

				function resize() {
					dpr = Math.max(1, window.devicePixelRatio || 1);
					width = window.innerWidth;
					height = window.innerHeight;
					canvas.style.width = width + 'px';
					canvas.style.height = height + 'px';
					canvas.width = Math.floor(width * dpr);
					canvas.height = Math.floor(height * dpr);
					ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
					ctx.globalCompositeOperation = 'lighter';
				}
				resize();
				window.addEventListener('resize', resize);

				function rand(min, max) { return Math.random() * (max - min) + min; }
				function pick(arr) { return arr[(Math.random() * arr.length) | 0]; }

				class Rocket {
					constructor(x) {
						this.x = x != null ? x : rand(width * 0.2, width * 0.8);
						this.y = height + rand(10, 40);
						this.vx = rand(-1.5, 1.5);
						this.vy = -rand(7, 12);
						this.color = pick(colors);
						this.targetY = rand(height * 0.25, height * 0.55);
						this.exploded = false;
					}
					update() {
						this.vy += gravity * 0.6; // ä¸Šå‡é˜¶æ®µé‡åŠ›ç¨å°
						this.x += this.vx;
						this.y += this.vy;
						if (!this.exploded && (this.y <= this.targetY || this.vy > -1)) {
							this.explode();
						}
					}
					draw() {
						ctx.save();
						ctx.shadowColor = this.color;
						ctx.shadowBlur = 10;
						ctx.globalAlpha = 0.9;
						ctx.fillStyle = this.color;
						ctx.beginPath();
						ctx.arc(this.x, this.y, 2.2, 0, Math.PI * 2);
						ctx.fill();
						ctx.restore();
					}
					explode() {
						this.exploded = true;
						const count = (rand(40, 90)) | 0;
						for (let i = 0; i < count; i++) {
							const angle = (i / count) * Math.PI * 2;
							const speed = rand(2.5, 6.5);
							const p = new Particle(this.x, this.y, this.color);
							p.vx = Math.cos(angle) * speed + rand(-0.6, 0.6);
							p.vy = Math.sin(angle) * speed + rand(-0.6, 0.6);
							particles.push(p);
						}
					}
				}

				class Particle {
					constructor(x, y, color) {
						this.x = x; this.y = y;
						this.vx = rand(-3, 3);
						this.vy = rand(-3, 3);
						this.size = rand(1.2, 2.6);
						this.alpha = 1;
						this.color = color;
						this.decay = rand(0.010, 0.020);
						this.tilt = rand(-0.02, 0.02);
					}
					update() {
						this.vx *= friction;
						this.vy *= friction;
						this.vy += gravity;
						this.x += this.vx + this.tilt;
						this.y += this.vy;
						this.size *= 0.995;
						this.alpha -= this.decay;
					}
					draw() {
						if (this.alpha <= 0 || this.size <= 0.2) return;
						ctx.save();
						ctx.globalAlpha = Math.max(0, this.alpha);
						ctx.shadowColor = this.color;
						ctx.shadowBlur = 12;
						ctx.fillStyle = this.color;
						ctx.beginPath();
						ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
						ctx.fill();
						ctx.restore();
					}
				}

				function spawnRocket(x) { if (rockets.length >= maxRockets) return; rockets.push(new Rocket(x)); }

				function frame(t) {
					ctx.clearRect(0, 0, width, height);
					if (t - lastSpawn > spawnInterval) { spawnRocket(); lastSpawn = t; }
					for (let i = rockets.length - 1; i >= 0; i--) {
						const r = rockets[i]; r.update(); r.draw(); if (r.exploded || r.y < -50) { rockets.splice(i, 1); }
					}
					if (particles.length > maxParticles) { particles.splice(0, particles.length - maxParticles); }
					for (let i = particles.length - 1; i >= 0; i--) {
						const p = particles[i]; p.update(); p.draw(); if (p.alpha <= 0 || p.y > height + 50) { particles.splice(i, 1); }
					}
					requestAnimationFrame(frame);
				}
				requestAnimationFrame(frame);

				function clickHandler(e) {
					const x = (e.clientX != null ? e.clientX : (e.touches && e.touches[0].clientX)) || width / 2;
					const burst = (rand(2, 4)) | 0;
					for (let i = 0; i < burst; i++) { spawnRocket(x + rand(-40, 40)); }
				}
				window.addEventListener('click', clickHandler, { passive: true });
				window.addEventListener('touchstart', clickHandler, { passive: true });
			})();
		</script>

		<script>
			const board = document.getElementById('board')
			const messages = [
				'æ¯å¤©ä¿æŒå¥½å¿ƒæƒ…',
				'æ•å®å¤©å¤©å¼€å¿ƒ~',
				'æˆ‘å–œæ¬¢æ™´å¤© ä½ æ°å¥½æ˜¯å¤ªé˜³â‰¥^â¦ğ–¥¦â¦^â‰¤',
				'åšçƒ­çƒˆè€Œè‡ªç”± èµ¤è¯šåˆå‹‡æ•¢çš„äºº',
				'å¤šå–æ°´å“¦',
				'ä»Šå¤©è¾›è‹¦å•¦',
				'æ— å¿§æ— è™‘ å¹³å®‰é¡ºé‚ å¹¸ç¦å¿«ä¹ å¥½è¿å¸¸åœ¨ï¼ï¼ï¼',
				'è®°å¾—åƒæ°´æœ',
				'ä¸é®æ© å¾ˆæƒ³ä½ ÕË¶ï½¥ÖŠï½¥Ë¶Õ',
				'å°çŒ«å‘†å‘†çš„ åƒä½ ÕË¶ï½¥ÖŠï½¥Ë¶Õ',
				'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±',
				'æœŸå¾…ä¸‹ä¸€æ¬¡è§é¢',
				'ä½  æˆ‘çš„å…¨ä¸–ç•ŒË¶Ëƒ áµ• Ë‚Ë¶',
				'æˆ‘å–œæ¬¢ä½ ',
				'å¤šå–œä¹ï¼Œé•¿å®‰å®ï¼Œå²æ— å¿§',
				'å¤©æ°”å†·äº†ï¼Œå¤šç©¿è¡£æœ',
				'å°å¾—ç›ˆæ»¡ï¼Œçˆ±é€¢å…¶æ—¶',
				'æˆ‘é‡ä½ å¦‚æ¯æœ¨é€¢æ˜¥Ë¶Ëƒ áµ• Ë‚Ë¶',
				'ä»Šå¤©ä¹Ÿè¦å¥½å¥½çˆ±è‡ªå·±',
				'è®°å¾—æƒ³æˆ‘å“¦'

			]

			const colors = [
				'#ffe0e3',
				'#c7f0ff',
				'#ffd8a8',
				'#d9f2d9',
				'#e5d7ff',
				'#f9f7d9',
				'#d2f0f8',
				'#ffd4f5'
			]

			const cardStates = new WeakMap()
			// Reserve a very highå±‚çº§ç»™å…¨å±å¡ç‰‡ï¼Œé¿å…è¢«åç»­å…ƒç´ è¦†ç›–
			const MAXIMIZED_LAYER = 1000000
			let activeMaximizedCard = null
			let isMobile =
				window.matchMedia('(pointer: coarse)').matches ||
				window.innerWidth <= 768
			const maxCards = isMobile ? 120 : 180 // é™åˆ¶ DOM èŠ‚ç‚¹æ•°é‡ï¼Œå‡è½»ç§»åŠ¨ç«¯å‹åŠ›
			const initialCardCount = isMobile ? 18 : 30
			const spawnInterval = isMobile ? 700 : 400
			let zIndexCursor = 200

			document.body.classList.toggle('is-mobile', isMobile)

			function randomFrom(array) {
				return array[Math.floor(Math.random() * array.length)]
			}

			function clamp(value, min, max) {
				return Math.min(Math.max(value, min), max)
			}

			function applyTransform(card, state) {
				const scale = state.scale ?? 1
				const translateX = state.translateX ?? 0
				const translateY = state.translateY ?? 0
				const angle = state.angle ?? 0
				card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`
			}

			function bringToFront(card) {
				if (card === activeMaximizedCard) {
					card.style.zIndex = MAXIMIZED_LAYER
					return
				}

				zIndexCursor += 1
				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
					zIndexCursor = MAXIMIZED_LAYER - 1
				}

				card.style.zIndex = zIndexCursor
			}

			function setupCardInteractions(card) {
				const header = card.querySelector('.card-header')
				const closeBtn = card.querySelector('.control.close')
				const minimizeBtn = card.querySelector('.control.minimize')
				const maximizeBtn = card.querySelector('.control.maximize')

				closeBtn.addEventListener('click', event => {
					event.stopPropagation()
					closeCard(card)
				})

				minimizeBtn.addEventListener('click', event => {
					event.stopPropagation()
					minimizeCard(card)
				})

				maximizeBtn.addEventListener('click', event => {
					event.stopPropagation()
					toggleMaximize(card)
				})

				header.addEventListener('pointerdown', event => {
					if (event.pointerType === 'touch') return
					startDrag(event, card)
				})

				card.addEventListener('pointerdown', () => {
					bringToFront(card)
				})

				header.addEventListener('dblclick', event => {
					if (!event.target.closest('.control')) {
						toggleMaximize(card)
					}
				})
			}

			function closeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return
				if (card === activeMaximizedCard) {
					activeMaximizedCard = null
				}
				state.closing = true
				state.scale = 0.1
				card.style.opacity = '0'
				applyTransform(card, state)

				const handleTransitionEnd = event => {
					if (event.propertyName === 'opacity') {
						card.removeEventListener('transitionend', handleTransitionEnd)
						card.remove()
					}
				}

				card.addEventListener('transitionend', handleTransitionEnd)
			}

			function minimizeCard(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				// æœ€å°åŒ–åŠ¨ç”»ï¼šç¼©å°å¹¶æ·¡å‡ºåˆ°åº•éƒ¨ï¼Œç»“æŸæ—¶ç§»é™¤èŠ‚ç‚¹é‡Šæ”¾å†…å­˜
				const runMinimize = () => {
					state.closing = true
					bringToFront(card)
					const bottom = Math.max(window.innerHeight - 24, 0)
					const targetLeft = clamp(
						state.left,
						16,
						Math.max(window.innerWidth - card.offsetWidth - 16, 16)
					)

					state.left = targetLeft
					state.top = bottom
					state.scale = 0.1
					state.angle = 0
					card.style.left = `${targetLeft}px`
					card.style.top = `${bottom}px`
					card.style.opacity = '0.35'
					applyTransform(card, state)

					const handleTransitionEnd = event => {
						if (event.propertyName === 'transform') {
							card.removeEventListener('transitionend', handleTransitionEnd)
							card.remove()
						}
					}

					card.addEventListener('transitionend', handleTransitionEnd)
				}

				if (state.maximized) {
					activeMaximizedCard = null
					state.maximized = false
					card.classList.remove('maximized')
					card.style.borderRadius = '12px'
					state.left = 0
					state.top = 0
					state.scale = 1
					state.angle = 0
					applyTransform(card, state)

					requestAnimationFrame(() => {
						requestAnimationFrame(runMinimize)
					})
					return
				}

				runMinimize()
			}

			function toggleMaximize(card) {
				const state = cardStates.get(card)
				if (!state || state.closing) return

				if (state.maximized) {
					restoreFromMaximize(card, state)
				} else {
					maximizeCard(card, state)
				}
			}

			function maximizeCard(card, state) {
				state.beforeMaximize = {
					left: state.left,
					top: state.top,
					scale: state.scale ?? 1,
					width: card.offsetWidth,
					height: card.offsetHeight,
					angle: state.angle ?? 0
				}

				card.classList.add('maximized')
				card.style.left = '0px'
				card.style.top = '0px'
				card.style.width = `${window.innerWidth}px`
				card.style.height = `${window.innerHeight}px`
				card.style.borderRadius = '0'

				state.left = 0
				state.top = 0
				state.scale = 1
				state.angle = 0
				applyTransform(card, state)
				activeMaximizedCard = card
				bringToFront(card)
				state.maximized = true
			}

			function restoreFromMaximize(card, state) {
				const previous = state.beforeMaximize
				if (!previous) return

				card.classList.remove('maximized')
				card.style.left = `${previous.left}px`
				card.style.top = `${previous.top}px`
				card.style.width = `${previous.width}px`
				card.style.height = `${previous.height}px`
				card.style.borderRadius = '12px'

				state.left = previous.left
				state.top = previous.top
				state.scale = previous.scale ?? 1
				state.angle = previous.angle ?? state.angle ?? 0
				applyTransform(card, state)
				state.maximized = false
				if (activeMaximizedCard === card) {
					activeMaximizedCard = null
				}
				bringToFront(card)
				state.lastPosition = { left: state.left, top: state.top }

				setTimeout(() => {
					if (!state.maximized) {
						card.style.width = ''
						card.style.height = ''
						state.width = card.offsetWidth
						state.height = card.offsetHeight
					}
				}, 360)
			}

			function startDrag(event, card) {
				const control = event.target.closest('.control')
				if (control) return

				const state = cardStates.get(card)
				if (!state || state.closing || state.maximized) return

				// é¼ æ ‡æ‹–æ‹½ä½¿ç”¨ rAF èŠ‚æµï¼Œé¿å…é¢‘ç¹è§¦å‘å¸ƒå±€è®¡ç®—
				event.preventDefault()
				bringToFront(card)

				const header = card.querySelector('.card-header')
				card.classList.add('dragging')
				header.classList.add('dragging')

				state.dragging = true
				state.dragOffsetX = event.clientX - state.left
				state.dragOffsetY = event.clientY - state.top

				let dragFrame = null
				let pendingLeft = state.left
				let pendingTop = state.top

				const commitDrag = () => {
					dragFrame = null
					const maxLeft = Math.max(window.innerWidth - card.offsetWidth, 0)
					const maxTop = Math.max(window.innerHeight - card.offsetHeight, 0)
					state.left = clamp(pendingLeft, -card.offsetWidth * 0.4, maxLeft)
					state.top = clamp(pendingTop, -card.offsetHeight * 0.4, maxTop)
					card.style.left = `${state.left}px`
					card.style.top = `${state.top}px`
				}

				const handlePointerMove = moveEvent => {
					if (!state.dragging) return

					pendingLeft = moveEvent.clientX - state.dragOffsetX
					pendingTop = moveEvent.clientY - state.dragOffsetY
					if (dragFrame === null) {
						dragFrame = requestAnimationFrame(commitDrag)
					}
				}

				const handlePointerUp = () => {
					state.dragging = false
					state.lastPosition = { left: state.left, top: state.top }
					card.classList.remove('dragging')
					header.classList.remove('dragging')
					if (dragFrame !== null) {
						cancelAnimationFrame(dragFrame)
						commitDrag()
					}
					document.removeEventListener('pointermove', handlePointerMove)
					document.removeEventListener('pointerup', handlePointerUp)
				}

				document.addEventListener('pointermove', handlePointerMove)
				document.addEventListener('pointerup', handlePointerUp)
			}

			function createCard() {
				const card = document.createElement('div')
				card.className = 'card'

				const color = randomFrom(colors)
				const angleRange = isMobile ? 6 : 10
				const angle = (Math.random() - 0.5) * angleRange
				const cardWidth = isMobile ? 180 : 220
				const cardHeight = isMobile ? 130 : 140
				const horizontalMargin = isMobile ? 12 : 16
				const verticalMargin = isMobile ? 12 : 20
				const left =
					horizontalMargin +
					Math.random() *
						Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0)
				const top =
					verticalMargin +
					Math.random() *
						Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0)

				card.style.background = color
				card.style.left = `${left}px`
				card.style.top = `${top}px`
				if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {
					zIndexCursor = MAXIMIZED_LAYER - 2
				}
				card.style.zIndex = ++zIndexCursor

				card.innerHTML = `
					<div class="card-header">
						<div class="window-controls">
							<button class="control close" type="button" aria-label="å…³é—­"></button>
							<button class="control minimize" type="button" aria-label="æœ€å°åŒ–"></button>
							<button class="control maximize" type="button" aria-label="æœ€å¤§åŒ–"></button>
						</div>
						<div class="card-title">æ¸©é¦¨æç¤º:</div>
					</div>
					<div class="card-body">${randomFrom(messages)}</div>
				`

				const state = {
					angle,
					scale: isMobile ? 0.85 : 0.7,
					translateX: 0,
					translateY: 0,
					left,
					top,
					maximized: false,
					closing: false,
					lastPosition: { left, top }
				}

				cardStates.set(card, state)
				applyTransform(card, state)
				board.appendChild(card)

				state.width = card.offsetWidth
				state.height = card.offsetHeight

				requestAnimationFrame(() => {
					state.scale = 1
					applyTransform(card, state)
					card.style.opacity = '1'
				})

				setupCardInteractions(card)

				if (board.children.length > maxCards) {
					const oldest = board.firstElementChild
					if (oldest && oldest !== card) {
						oldest.remove()
					}
				}
			}

			for (let i = 0; i < initialCardCount; i++) {
				setTimeout(createCard, i * (isMobile ? 60 : 40))
			}

			setInterval(() => {
				createCard()
			}, spawnInterval)

			window.addEventListener('resize', () => {
				isMobile =
					window.matchMedia('(pointer: coarse)').matches ||
					window.innerWidth <= 768
				// è§†å£å˜åŒ–æ—¶é‡æ–°åˆ‡æ¢ç§»åŠ¨ç«¯æ¨¡å¼ï¼Œå¹¶åŒæ­¥å…¨å±å¡ç‰‡çš„å®½é«˜
				document.body.classList.toggle('is-mobile', isMobile)

				document.querySelectorAll('.card.maximized').forEach(card => {
					card.style.width = `${window.innerWidth}px`
					card.style.height = `${window.innerHeight}px`
				})
			})
		</script>
	</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>é£˜è½åŠ¨æ¼«çˆ±å¿ƒæ•ˆæœ</title>
    <style>
        /* è¦†ç›–å±‚å®¹å™¨ */
        #hearts-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        /* å¿ƒå½¢å…ƒç´ ï¼šç”¨ä¸€ä¸ªæ–¹å—åŠ ä¸¤ä¸ªåœ†ç»„åˆæˆå¿ƒå½¢ */
        .heart {
            position: absolute;
            top: -10vh;
            left: 50%;
            width: var(--size, 18px);
            height: var(--size, 18px);
            background: var(--color, #ff6f91);
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,.18)) drop-shadow(0 0 6px rgba(255,255,255,.6));
            animation: fall var(--duration, 8s) linear var(--delay, 0s) forwards;
            opacity: 0;
        }

        .heart::before, .heart::after {
            content: "";
            position: absolute;
            width: var(--size, 18px);
            height: var(--size, 18px);
            background: var(--color, #ff6f91);
            border-radius: 50%;
        }
        /* å·¦ä¸Šåœ† */
        .heart::before {
            top: calc(var(--size, 18px) * -0.5);
            left: 0;
        }
        /* å³ä¸Šåœ† */
        .heart::after {
            top: 0;
            left: calc(var(--size, 18px) * 0.5);
        }

        /* ä¸‹è½åŠ¨ç”»ï¼šå¸¦æ—‹è½¬å’Œè½»å¾®ç¼©æ”¾ï¼Œè¥é€ â€œåŠ¨æ¼«æ„Ÿâ€ */
        @keyframes fall {
            0% {
                transform: translateY(-10vh) rotate(-45deg) scale(0.9);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            50% {
                transform: translateY(50vh) rotate(135deg) scale(1.05);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) rotate(315deg) scale(1.15);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="hearts-container"></div>

    <script>
        (function () {
            const container = document.getElementById('hearts-container');

            // å¯è‡ªè¡Œä¿®æ”¹çš„é¢œè‰²ç»„ï¼ˆåâ€œåŠ¨æ¼«ç²‰â€ï¼‰
            const colors = [
                '#ff4d6d', '#ff6f91', '#ff85a1', '#ff99cc',
                '#fc2b64', '#f05475', '#e94057', '#fda4af'
            ];

            // è°ƒæ•´é¢‘ç‡å’Œå¹¶å‘æ•°é‡
            const density = 280; // å¿ƒç”Ÿæˆçš„æ—¶é—´é—´éš”ï¼ˆæ¯«ç§’ï¼‰
            const maxHearts = 60; // åŒæ—¶æœ€å¤šå­˜åœ¨çš„å¿ƒå½¢æ•°é‡

            let liveHearts = 0;

            function spawnHeart() {
                const heart = document.createElement('div');
                heart.className = 'heart';

                // éšæœºå¤§å°ã€é¢œè‰²ã€ä½ç½®ã€æ—¶é•¿ä¸å»¶è¿Ÿ
                const size = 12 + Math.random() * 20;           // 12px ~ 32px
                const duration = 6 + Math.random() * 6;         // 6s ~ 12s
                const delay = -Math.random() * 3;               // è´Ÿå»¶è¿Ÿï¼Œæ‰“æ•£èµ·å§‹ç›¸ä½
                const leftPercent = Math.random() * 100;        // 0% ~ 100%
                const color = colors[Math.floor(Math.random() * colors.length)];

                heart.style.setProperty('--size', size + 'px');
                heart.style.setProperty('--color', color);
                heart.style.setProperty('--duration', duration + 's');
                heart.style.setProperty('--delay', delay + 's');
                heart.style.left = leftPercent + '%';

                container.appendChild(heart);
                liveHearts++;

                // åœ¨åŠ¨ç”»ç»“æŸåç§»é™¤ DOMï¼Œé¿å…å †ç§¯
                const life = (duration) * 1000;
                setTimeout(() => {
                    heart.remove();
                    liveHearts--;
                }, life + 1000);
            }

            // å®šæ—¶ç”Ÿæˆ
            const timer = setInterval(() => {
                if (liveHearts < maxHearts) {
                    spawnHeart();
                }
            }, density);

            // äº¤äº’ï¼šç‚¹å‡»å±å¹•è§¦å‘ä¸€å°æ³¢â€œè¿å‘â€
            window.addEventListener('click', () => {
                const burst = 10;
                for (let i = 0; i < burst; i++) {
                    setTimeout(spawnHeart, i * 70);
                }
            });
        })();
    </script>
    </body>
</html>
